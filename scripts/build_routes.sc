import scala.collection.mutable

// Utilities for processing vizier-routes.txt into source code

val SOURCE_DIR = os.pwd / "vizier"
val BACKEND_DIR = SOURCE_DIR / "backend" / "src" / "info" / "vizierdb"
val UI_DIR      = SOURCE_DIR / "ui"      / "src" / "info" / "vizierdb"

// vizier-routes.txt contains a list of routes with information about the
// structure of the request, handler information, and other metadata.
// The file is whitespace-delimited, with the following columns:
//  1. route: '/'-delimited.  An entry of the form {label:type} indicates a 
//     variable parameter that will be assigned the specified name.  See Path
//     Types below
//  2. HTTP Verb: e.g. GET, POST, etc...
//  3. Domain: A label indicating the subject of the action.  Not used directly
//     but can serve to differentiate different authentication domains (See
//     Domains below)
//  4. Action: A short tag identifying the action.  These are used to create
//     method names in generated classes, and to make everything readable.
//  5. Handler: The name of an object in the `info.vizierdb.api` package that
//     has an `apply` method that accepts all of the listed parameters.
//  6. Return Payload: The scala return-type of the handler, or the special
//     return type FILE[mime/type].  This class must be play-json-serializable.
//     See FILEs below
//  7. A ';'-delimited list of "label:type" pairs indicating json-serialized 
//     parameters to the method.  These will be deserialized and passed as 
//     arguments to the function.  Types are Scala types, or the special
//     type FILE (see below)
// 
// --- Path Types ---
// - long: Translates to Long or Identifier
// - int: Translates to Int
// - subpath: Must be the last element of a route.  Matches everything and 
//            returnsa string containing the rest of the route
// 
// --- Domains ---
// - service: General API methods not related to any specific project
// - project: One project (group of notebooks)
// - branch: One branch in a project
// - workflow: One workflow in one branch in a project
// - artifact: An artifact in a project
// - published: An artifact that has been published
// - fs: API access to the filesystem (or other data source connectors)
//
// --- FILEs ---
// Some routes need direct access to file IO.  For example when downloading 
// a file, the handler needs to be able to return a file.
//

val INPUT = SOURCE_DIR / "resources" / "vizier-routes.txt"

/////////////////////// Backend /////////////////////// 
// Vizier uses Akka to route http requests to handlers.
// This script will generate It will generate a single file 
val SERVER_ROUTES = BACKEND_DIR / "api" / "akka"
def DOMAIN_ROUTES(domain: String) = SERVER_ROUTES / s"RoutesFor${domain.capitalize}.scala"
val MAIN_ROUTES   = SERVER_ROUTES / "AllRoutes.scala"

// We also provide an API for invoking many of the routes 
// over the websocket (this is necessary to ensure ordering
// and avoid race conditions).  The backend component of this API
// is here:
val WEBSOCKET_IMPL = BACKEND_DIR / "api" / "websocket" / "BranchWatcherAPIRoutes.scala"

///////////////////////   UI    ///////////////////////

// We ensure typesafe invocation of API methods in the frontend by
// providing a proxy wrapper.
val API_PROXY = UI_DIR / "ui" / "network" / "API.scala"

// And a similar wrapper for invoking methods over the websocket.
val WEBSOCKET_PROXY = UI_DIR / "ui" / "network" / "BranchWatcherAPIProxy.scala"

val AUTOGEN_HEADER = 
  """/***************************************************************/
    |/**              DO NOT EDIT THIS FILE DIRECTLY               **/
    |/** It was automatically generated by scripts/build_routes.sc **/
    |/** Edit that file instead.                                   **/
    |/***************************************************************/
    """.stripMargin


///////////////////////////////////////////////////////
////////////// Read vizier-routes.txt /////////////////
///////////////////////////////////////////////////////

sealed trait PathComponent

case class PathLiteral(value: String) extends PathComponent
case class PathVariable(identifier: String, dataType: String) extends PathComponent
{
  def scalaType = 
    dataType match {
      case "int" => "Int"
      case "long" => "Long"
      case "subpath" => "String"
      case "string" => "String"
    }

  def toParam = 
    Param(identifier, scalaType)

  def cast(target: String) = 
    dataType match {
      case "int"  => s"$target.toInt"
      case "long" => s"$target.toLong"
      case "subpath" => target
      case "string" => target
    }
}

case class Param(identifier: String, scalaType: String)
{
  def typedIdentifier = s"$identifier:$scalaType"

  def nativeScalaType = 
    scalaType.replaceAll("UndefOr", "Option")

  def typedNativeIdentifier = s"$identifier:$nativeScalaType"

}
case class Route(
  path : Seq[PathComponent],
  pathQueryParams: Seq[PathVariable],
  verb : String,
  domain: String,
  action: String,
  handler: String,
  returns: String,
  jsonParams: Seq[Param],
  fileParam: Option[String],
)
{
  def allParams = Seq[Seq[Param]](
    path.collect { case p:PathVariable => (p:PathVariable).toParam },
    pathQueryParams.map { _.toParam },
    jsonParams
  ).flatten

  def jsonParamClassName: Option[String] =
    if(jsonParams.isEmpty){ None }
    else { 
      Some(s"${action.capitalize}Parameter")
    }

  def jsonParamClass: Option[String] =
    jsonParamClassName.map { clazz => 
      s"""case class $clazz(
         |  ${jsonParams.map { _.typedNativeIdentifier }.mkString(",\n  ")}
         |)""".stripMargin
    }
}

val PATH_VARIABLE = "\\{(\\w+):(\\w+)\\}".r

val ROUTES: Seq[Route] = 
  os.read(INPUT).split("\n")
    .map { description => 
      val components = description.split("\\s+")
      val pathAndArguments = components(0).split("\\?")
      val path = pathAndArguments(0).split("/").toSeq
      val pathQuery:Seq[PathVariable] = 
        if(pathAndArguments.size > 1){ 
          pathAndArguments(1).split("&")
                             .map { _.split(":").toSeq }
                             .map {
                              case Seq(identifier, dataType) => PathVariable(identifier, dataType)
                             }
        } else { Seq.empty }
      assert(path.isEmpty || path(0) == "")

      val jsonParams:Seq[Param] =
        components(6) match {
          case "-" | "_" => Seq()
          case x => x.split(";")
            .map { _.split(":").toSeq }
            .map { 
              case Seq(identifier, dataType) => Param(identifier, dataType) 
              case x => throw new Exception(s"Invalid parameter: ${x.mkString(",")}")
            }
        }

      val paramIsFile =
        !jsonParams.filter { _.scalaType == "FILE" }.isEmpty

      assert(!paramIsFile || jsonParams.size == 1)

      Route(
        path = path.drop(1).map {  
          case PATH_VARIABLE(identifier, dataType) => PathVariable(identifier, dataType)
          case x => PathLiteral(x)
        },
        pathQueryParams = pathQuery,
        verb = components(1),
        domain = components(2),
        action = components(3),
        handler = components(4),
        returns = components(5),
        jsonParams = if(paramIsFile){ Seq() } else { jsonParams },
        fileParam = if(paramIsFile){ Some(jsonParams(0).identifier) } else { None }
      )
    }

///////////////////////////////////////////////////////
//////////////////  Akka Routes   /////////////////////
///////////////////////////////////////////////////////

def akkaRouteHandler(routeAndIndex: (Route, Int)): String =
{
  val (route: Route, idx: Int) = routeAndIndex
  val path = 
    route.path.map {
      case PathLiteral(component) => s"\"$component\""
      case PathVariable(_, "int") => "IntNumber"
      case PathVariable(_, "long") => "LongNumber"
      case PathVariable(_, "subpath") => "Remaining"
      case PathVariable(_, "string") => "Segment"
    } :+ "PathEnd"

  val (pathParamInputs, pathParamOutputs) = 
    route.path.collect { 
      case p:PathVariable => 
        (p.toParam.typedIdentifier, 
          s"${p.identifier} = ${p.identifier}")
    }.unzip

  var extractors = mutable.ArrayBuffer[String]()

  if(!pathParamInputs.isEmpty) {
    extractors.append(
      s"(${pathParamInputs.mkString(", ")}) => {"
    )
  }

  val jsonParamOutputs =
    route.jsonParams.map { param =>
      s"${param.identifier} = jsonEntity.${param.identifier}"
    }

  if(!jsonParamOutputs.isEmpty){
    extractors.append("decodeRequest {")
    extractors.append(
      s"entity(as[${route.jsonParamClassName.get}]) { jsonEntity => "
    )
  }

  val fileParamOutputs = 
    route.fileParam.map { identifier => 
      extractors.append(s"VizierServer.withFile(\"${identifier}\") { fileEntity => ")
      s"$identifier = fileEntity"
    }

  val queryStringParamOutputs =
    route.pathQueryParams.map { param =>
      s"${param.identifier} = query.get(\"${param.identifier}\").map { x => ${param.cast("x")} }"
    }

  if(!queryStringParamOutputs.isEmpty){
    extractors.append("extractRequest { httpRequest => val query = httpRequest.getUri.query.toMap.asScala")
  }

  val allParams =
    pathParamOutputs ++
    jsonParamOutputs ++
    fileParamOutputs ++
    queryStringParamOutputs

  s"""  val ${route.action}Route${idx} =
     |    path(${path.mkString(" / ")}) { ${extractors.map { "\n      "+_ }.mkString}
     |        ${route.verb.toLowerCase} { 
     |          ${route.handler}(${allParams.mkString(", ")})
     |        }${if(extractors.isEmpty){""} else { "\n      "+extractors.map { _ => "}" }.mkString(" ") }}
     |    }
     |  """.stripMargin
}

val routesByDomain = ROUTES.groupBy { _.domain }

for( (domain, routes) <- routesByDomain )
{
  val file = DOMAIN_ROUTES(domain)
  val clazz = file.baseName
  println(s"$domain -- $clazz --> $file")

  val jsonParamClasses =
    routes.flatMap { _.jsonParamClass.map { _.split("\n")
                                             .map { "  " + _ }
                                             .mkString("\n") } }
          .mkString("\n\n")
  val data = 
    s"""package info.vizierdb.api.akka
       |$AUTOGEN_HEADER
       |import play.api.libs.json._
       |import akka.http.scaladsl.model._
       |import akka.http.scaladsl.server.Directives._
       |import akka.http.scaladsl.model.headers.`Content-Type`
       |import akka.http.scaladsl.model.HttpHeader
       |import info.vizierdb.api._
       |import info.vizierdb.serialized
       |import info.vizierdb.serializers._
       |import info.vizierdb.types._
       |import de.heikoseeberger.akkahttpplayjson.PlayJsonSupport._
       |import VizierServer.RouteImplicits._
       |import scala.jdk.CollectionConverters._
       |import info.vizierdb.spark.caveats.CaveatFormat._
       |
       |object $clazz
       |{
       |$jsonParamClasses
       |
       |${routes.flatMap { _.jsonParamClassName }
                .map { n => s"  implicit val ${n}Format: Format[$n] = Json.format"}
                .mkString("\n")}
       |
       |${routes.zipWithIndex.map { akkaRouteHandler(_)}.mkString("\n\n")}
       |
       |  val routes = concat(
       |    ${routes.zipWithIndex.map { case (route, idx) => s"${route.action}Route$idx" }.mkString(",\n    ")}
       |  )
       |}
       """.stripMargin

  os.write.over(file, data)
  println(data)
}

{
  val file = MAIN_ROUTES
  val clazz = file.baseName
  val domainClasses = 
    routesByDomain.keys.map { DOMAIN_ROUTES(_).baseName }
  val data =
    s"""package info.vizierdb.api.akka
       |$AUTOGEN_HEADER
       |import akka.http.scaladsl.model._
       |import akka.http.scaladsl.server.Directives._
       |import akka.http.scaladsl.model.headers.`Content-Type`
       |import akka.http.scaladsl.model.ContentTypes._
       |import akka.http.scaladsl.model.HttpHeader
       |
       |object $clazz 
       |{
       |  val routes = concat(
       |    ${domainClasses.map { _ + ".routes"}.mkString(",\n    ") }
       |  )
       |}
       """.stripMargin
  println(data)
  os.write.over(file, data)
  routesByDomain.keys
}
